\documentclass[sigconf, review=false]{acmart}

\usepackage[utf8]{inputenc}
\usepackage{booktabs} % For formal tables
\usepackage{graphicx}
\graphicspath{{yuanzhong-imgs/}}
\usepackage{float}
\PassOptionsToPackage{hyphens}{url}
\usepackage{hyperref}
\usepackage{multirow}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{gensymb}
\usepackage{textcomp}
\usepackage{xspace}

\let\OldTexttrademark\texttrademark
\renewcommand{\texttrademark}{\OldTexttrademark\xspace}%

%% template settings
\settopmatter{printacmref=false} % Removes citation information below abstract
\renewcommand\footnotetextcopyrightpermission[1]{} % removes footnote with conference information in first column


%% title and name
\begin{document}
\title{Mobile \& Wireless Systems Final Report}
\subtitle{Crypto4CRFID}

\author{Yuanzhong Xia}
\affiliation{
  \institution{The University of Adelaide}
  \city{Adelaide}
  \state{SA}
  \postcode{5005}
}
\email{a1700831@student.adelaide.edu.au}

% ---------
%% abstract
% ---------
\begin{abstract}
    This report firstly introduces the background and motivation of this project, which is to build a secure CRFID system.
    Then, our system overview, system components and my contributions are mentioned in detail.
    My contribution include the lightweight block cipher algorithm study, hash function study and optimization study.
    Besides, others' related works on cryptanalysis, hash function cryptanalysis are mentioned as well.
    In the end, there are conclusions and my reflections about the whole project.
\end{abstract}
\keywords{Embedded System, RFID, Encryption, Hash, MSP430, Optimization, Security}
\maketitle


% --------------
%% main contents
% --------------

% Excellent introduction and motivation of the project, clearly outlining the potential of the work.
\section{Introduction and Motivation}
Radio Frequency Identification (RFID) technologies have been widely used in our daily lives:
student cards, contactless payment, object tracking (like airport baggages, express packages and experimental animals),
item identification, distributed wireless sensor networks used for environment monitoring, etc. \cite{wikipedia2017rfid}
They are normally built with Application Specific Integrated Circuits (ASIC).

Unlike RFID, Computational RFID (CRFID) that our studies are based on has an ultra low power microcontroller (MCU),
thus it has a firmware software which we can specifically modify for our applications.
The firmware follows the EPC\texttrademark Radio-Frequency Identity Protocols Class-1 Generation-2 UHF RFID version 2\cite{epcglobal2013}.
This standard defines how a tag is captured by a reader, and how information are transmitted between reader and tag.
It also contains several custom security extension commands for developers to use in their implementations.

However, CRFID has a limited amount of computational resources, which determines that it is unlikely to apply
modern high-computational-complex encryption algorithms (like RSA algorithm) on it.
Therefore, to build a security system becomes a crucial problem in research area.

In this project, we mainly try to build a secure CRFID system
% Not implemented: the CRFID tag can verify a reader's legitimacy and
where the reader can identify a CRFID's legitimacy.
After passing the two-way verification, they can transfer the critical data securely.

\subsection{Devices}
In this project, we use WISP 5 \footnote{WISP5 - WISP Home: \url{https://wisp5.wikispaces.com/WISP+Home}.} (shown in Figure \ref{fig-wisp5})
as the CRFID experimental device.
It contains a Texas Instruments (TI) MSP430FR5969 MCU \footnote{MSP430\texttrademark FR5969 16 MHz Ultra-Low-Power MCU: \url{http://www.ti.com/product/MSP430FR5969}.}
which uses 16-bit architecture with up to 16â€‘MHz Clock, and has 2 KB Static Random Access Memory (SRAM) and 64 KB Ferroelectric RAM (FRAM).

\begin{figure*}
\centering
\includegraphics[width=0.6\textwidth]{wisp5.png}
\caption{WISP 5 CRFID.}
\label{fig-wisp5}
\end{figure*}

The firmware is run by the MSP430 MCU. Hence, I only need to test algorithms on MSP430RF5969 no matter what CRFID I use.
Moreover, we have only one WISP 5, and another team member needs it to test the communication between CRFID and reader.
Therefore, I use another MSP430FR5969 come with MSP430FR5969 LaunchPad Development Kit
\footnote{MSP-EXP430FR5969 MSP430FR5969 LaunchPad Development Kit: \url{http://www.ti.com/tool/MSP-EXP430FR5969}.}
shown in Figure \ref{fig-launchpad}.

\begin{figure}
\centering
\includegraphics[width=0.4\textwidth]{launchpad.jpg}
\caption{MSP430FR5969 LaunchPad.}
\label{fig-launchpad}
\end{figure}

For debugging, there is no difference theoretically, plus, it provides some additional useful tools
like EnergyTrace++\texttrademark which can trace MCU current consumption.
As a result, all my experiments in this project are tested on this LaunchPad.

\subsection{System Overview}
The whole system architecture is shown in Figure \ref{fig-arch}.
This system contains two components: PC client and WISP 5.

\begin{figure*}
\centering
\includegraphics[width=0.7\textwidth]{arch.pdf}
\caption{System architecture.}
\label{fig-arch}
\end{figure*}

PC client contains a database storing a copy of FRAM and SRAM signature
(used by Physical Unclonable Functions implemented by teammate Yang Su).
Each copy of FRAM and SRAM are indexed by unique EPC value.

WISP 5 is supposed to contain legit EPC value which is stored in PC's database,
legit firmware which will be verified by my hash function,
and legit SRAM signature which is used for generating real random number.

The communication between PC client and WISP 5 follows the EPCglobal standard,
the extended security command is implemented by teammate Sangyeol Kim.
When connection established, PC will send WISP 5 a challenge which contains the beginning address and the round count.
Round count is used together with \textit{t}-function (implemented by teammate Jingwen Shan),
which will be introduced in Section \ref{sec-int} in detail.
Once WISP 5 receives the challenge, it runs the hash function implemented by me to get a checksum and send it back to PC client;
Meanwhile, PC client uses the same hash function to calculate the checksum, and compare it with the received checksum.
If they matches, the WISP 5 is regarded as a legit one.

\section{Related Works}
\subsection{Lightweight Block Cipher Algorithms}
Papers on lightweight block cipher algorithms are mentioned in Section \ref{sec-block} in detail.
Hence, they are not discussed with related works.

Besides, there some benchmark survey papers on lightweight block cipher algorithms:

\begin{itemize}
    \item In 2013, Cazorla \textit{et al.} published a survey paper comparing the performance between
          many lightweight block cipher algorithms using an MSP430 simulator called ``mspdebug''.
          \footnote{mspdebug GitHub repository: \url{https://github.com/dlbeer/mspdebug}.} \cite{cazorla2013survey}
    \item In 2014, Buhrow \textit{et al.} published a survey paper comparing different implementations
          of selected lightweight block cipher algorithms. \cite{buhrow2014block}
    \item In 2015, Cazorla \textit{et al.} again published a new survey paper comparing the performance between
          a set of lightweight block cipher algorithms using a real MSP430FG4618 device. \cite{cazorla2015survey}
    \item In 2017, Hatzivasilis \textit{et al.} published a survey on more than 30 lightweight block cipher algorithms.
          They only did some benchmark because a part of the algorithms did not have reference implementations. \cite{hatzivasilis2017review}
\end{itemize}

However, the first three survey papers did not mention cryptanalysis of the selected block cipher algorithms.
The last paper mentioned the cryptanalysis, but it used the standard 8051 MCU and the ATtiny45, instead of MSP430.

Moreover, the two papers from Cazorla \textit{et al.} conflicts with each other.
As well, our experiment results on MSP430FR5969 are in conflict with Cazorla \textit{et al.}'s two papers.
That is also one of the project's motivations.

\subsection{Cryptographic Hash Functions}
As far as I know, there is no cryptographic hash function survey researches from 2010.
A most-cited one is survey paper from Bakhtiari \textit{et al.} in 1995 \cite{bakhtiari1995cryptographic}.
The functions they discussed in that paper are MD2, MD4, MD5 and SHA-1.
However it is not useful now because all those discussed functions are full attacked:

\begin{itemize}
    \item MD2 was shown to be vulnerable for collision by Muller in 2004,
          using a preimage attack with a time complexity equivalent to $2^{104}$. \cite{muller2004md2}
    \item MD4 was fully collided using cheap computational cost by Leurent
          using preimage attack in a time complexity of $2^{102}$ in 2008. \cite{leurent2008md4}
    \item MD5 has been proved its distribution is not safe since 2004 \cite{hawkes2004musings}.
          Later in 2013, Xie \textit{et al.} published a method for a very quick collision attack \cite{xie2013fast},
          which takes less than a second to attack it on a regular computer.
    \item SHA-1 was also fully proved to be vulnerable for collision, using multi-block collision techniques
          by Wang \textit{et al.} since 2005. \cite{wang2005finding}
\end{itemize}

Besides, there are many cryptographic hash function papers using block ciphers to construct hash functions.
However, nearly all of the block ciphers are with key and block of same sizes.
I can hardly find a paper constructing a hash function constructed using key and block of different sizes.
This is not really helpful because the block ciphers we study are with various sizes of key and block.
Therefore, this is the reason why I refer to open-source projects to seek \textit{g}-functions used for constructions
in Section \ref{sec-one}.

\subsection{Algorithm Optimization on MSP430}
I have searched for ``assembly language'', ``MSP 430'' and ``Optimization'' key words on Google\texttrademark Scholar.
The only results that I can find are about factory assembly lines or sequences.

Additionally, the algorithms are evolutionary computation technologies. For example:

\begin{itemize}
    \item Dini \textit{et al.} derived a Genetic Algorithm to optimize assembling a simulated CAD product
          to find a better sequence that assembles quickly. \cite{dini1999generation}
    \item Haq \textit{et al.} derived a method to optimize load balance on assembly line
          using a hybrid genetic algorithm. \cite{haq2006hybrid}
\end{itemize}

Above all, as far as I know, there is on manual code optimization researches
on assembly programming language or MSP430 programming.
Therefore, I referred to some online materials which are mentioned in Section \ref{sec-low}.


\section{Lightweight Block Cipher Algorithm} \label{sec-block}

A lightweight implementation is defined as requiring up to 32 KB ROM and 8 KB RAM by Manifavas \textit{et al.}'s work\cite{manifavas2014lightweight}.
All our selected lightweight algorithms satisfy these requirements.
Moreover, in this project, we need decipher functions only because cipher operations can be performed in PC which has rich computational resources.

At the beginning, we selected seven block cipher algorithms from Cazorla \textit{et al.}'s two papers \cite{cazorla2013survey, cazorla2015survey}.
Those seven algorithms were AES-128\cite{pub2001197}, LBlock\cite{wu2011lblock}, MIBS-64\cite{izadi2009mibs},
Piccolo-128\cite{shibutani2011piccolo}, SEA\cite{standaert2006sea}, SPECK64-128\cite{beaulieu2015simon}, XTEA\cite{needham1997tea, wheeler1998correction}.
The experiments results can be seen in Table \ref{tab-beg}.

\begin{table*}[tbp]
\centering
\caption{Experiments on AES-128, LBlock, MIBS-64, Piccolo-128, SEA, SPECK64-128 and XTEA,
using TI v2016 compiler -O3 speed optimization.
Column ``Begin'' means cumulated cycle counter at the entry of the decipher function;
while column ``End'' means the cumulated cycle count after the decipher function returns.
Therefore, column ``Cycle count'' equals to the difference between ``End'' and ``Begin''.
Code size is the decipher function's binary code size;
whereas the internal state size is the maximum in-use local variable size (function parameters are excluded).}
\label{tab-beg}
\begin{tabular}{lcrrrrr}
    \toprule
Algorithm   & Type     & Begin & End   & Cycle count & Code size (bytes) & Internal state size (bytes) \\
    \midrule
AES         & decipher & 233   & 26303 & 26070       & 2538              & 18                          \\
LBlock      & decipher & 94    & 8300  & 8206        & 374               & 10                          \\
MIBS64      & decipher & 176   & 26312 & 26136       & 720               & 18                          \\
Piccolo128  & decipher & 215   & 16137 & 15922       & 2124              & 24                          \\
SEA         & decipher & 116   & 21682 & 21566       & 678               & 18                          \\
SPECK64-128 & decipher & 327   & 25328 & 25001       & 414               & 20                          \\
XTEA        & decipher & 115   & 12430 & 12315       & 666               & 24                          \\
    \bottomrule
\end{tabular}
\end{table*}

After that, I got a new requirement - finding lightweight block cipher algorithms of which at least half rounds remained un-attacked.
As a result, I found that some of our candidates had been fully attacked.
These algorithms were: MIBS and PRESENT \cite{bogdanov2007present} full-round attacked by Sereshgi \textit{et al.} \cite{sereshgi2016biclique},
Piccolo full-round attacked by Han \textit{et al.} \cite{han2017improved}, Klein \cite{gong2011klein} full-round attacked by Ahmadian \textit{et al.} \cite{ahmadian2015biclique},
LED \cite{Guo:2011:LBC:2044928.2044958} and mCrypton \cite{lim2005mcrypton} full-round attacked by Jeong \textit{et al.} \cite{jeong2015weakness},
and TWINE \cite{suzaki2012twine} full-round attacked by Najarkolaei \textit{et al.} \cite{najarkolaei2016biclique}.
Those unsafe algorithms are not studied in this project anymore.

Finally, the selected ten secure lightweight block cipher algorithms are:
AES-128, Camellia \cite{aoki2000camellia}, CLEFIA \cite{shirai2007128}, LBlock, LEA \cite{hong2013lea},
PRINCE \cite{borghoff2012prince}, SEA, SIMON \cite{beaulieu2015simon}, SPECK and XTEA.

My survey results on their cryptanalysis and best attack records are shown in Table \ref{tab-security}.

\begin{table*}[tbp]
\centering
\caption{Survey results on selected secure block cipher algorithms.}
\label{tab-security}
\begin{tabular}{lrcrrr}
    \toprule
Name (block/key)   & Reference & Structure & Round (attacked/total) & Attack time complexity & Attack reference \\
    \midrule
AES128 (128/128) & \cite{pub2001197} & SPN & 7/10 & $2^{100}$ & \cite{derbez2013improved} \\
Camellia (128/128) & \cite{aoki2000camellia} & Feistel & 11/18 & $2^{121.3}$ & \cite{li2015meet} \\
CLEFIA (128/128) & \cite{shirai2007128} & Feistel & 14/18 & $2^{108}$ & \cite{li2015meet} \\
LBlock (64/80) & \cite{wu2011lblock} & Feistel   & 24/32 & $2^{75.42}$ & \cite{xie2017related} \\
LEA (128/128) & \cite{hong2013lea} & ARX & 14/24 & $2^{124.02}$ & \cite{song2016automatic} \\
PRINCE (64/128) & \cite{borghoff2012prince} & SPN & 9/12 & $2^{55.14}$ & \cite{cheng2017multidimensional} \\
SEA (96/96) & \cite{standaert2006sea} & Feistel & (N/A)/95 & N/A & N/A \\
SIMON (64/128) & \cite{beaulieu2015simon} & Feistel & 31/44 & $2^{119.62}A+2^{120.00}E$\tnote{*} & \cite{chen2016improved} \\
SPECK (64/128) & \cite{beaulieu2015simon} & Feistel & 19/27 & $2^{125}$ & \cite{dinur2014improved} \\
XTEA (64/128) & \cite{wheeler1998correction} & Feistel & 27/64 & $2^{120.71}$ & \cite{bogdanov2012zero} \\
    \bottomrule
\end{tabular}
\end{table*}

For those algorithms, we use the reference codes from Cazorla \textit{et al.}
\footnote{Source code developed in the BLOC project: \url{https://github.com/kmarquet/bloc}} by default.
If the algorithm is not implemented by Cazorla \textit{et al.}, the reference implementation will be mentioned in the following texts.

\begin{itemize}
    \item
\textbf{AES}. The AES \cite{pub2001197} is a very popular studied algorithm, and it has both hardware and software implementations.
In this paper, we discuss 128-bit-key version only. So far, successful 7-round (out of ten) attacks have been published by many researchers,
and the best time complexity we could find is $2^{100}$ by Derbez \textit{et al.} \cite{derbez2013improved}.

    \item
\textbf{Camellia}. The Camellia \cite{aoki2000camellia} has variable key sizes and we only study the 128-bit key size version with 128-bit block.
The codes we use to test for this algorithm are the latest version (v1.2.0) from the company officially \cite{ntt2007},
and the greatest round attack is on 11-round by Li \textit{et al.} \cite{li2015meet}.

    \item
\textbf{CLEFIA}. The CLEFIA \cite{shirai2007128} is developed by Sony \cite{sony2008},
and it has 128-bit block and three different key size versions: 128-bit, 192-bit and 256-bit keys.
In this paper we discuss 128-bit key version because smaller key versions are often faster.
Most attacks on CLEFIA are based on 192-bit key and 256-bit key versions, hence there are less attacks on 128-bit key version.
The greatest round attack we could find on 128-bit key version is on 14-round also by Li \textit{et al.} \cite{li2015meet}.

    \item
\textbf{LBlock}. The LBlock \cite{wu2011lblock} has 32 rounds with 64-bit block and 80-bit key.
The best attack using Related-Key Impossible Differential is on 24-round with a time complexity of $2^{75.42}$ by Xie \textit{et al.} \cite{xie2017related}.

    \item
\textbf{LEA}. The LEA \cite{hong2013lea} is designed for 32 bit processor which the authors think is the most common processor type,
and the best attack is 14-round attack by Song \textit{et al.} \cite{song2016automatic}.
It takes 128-bit key and 128-bit block. To test it on MSP430, we use an 8-bit implementation by KISA \cite{kisa2015}.

    \item
\textbf{PRINCE}. The PRINCE \cite{borghoff2012prince} takes 64-bit block and 128-bit key.
The best attack is on 9th round (out of 12) with time complexity of $2^{55.14}$.
This block cipher uses a lot of 64-bit operations which can be found on the reference implementation by Riou \cite{sebastienriou2016}.
Therefore, to test it on MSP430, we use an 8-bit implementation by Dare \cite{chrisdare2016}.

    \item
\textbf{SEA}. The SEA \cite{standaert2006sea} block cipher we use in this paper has 96-bit block size and key size.
According to the original paper, the author suggests to use $\frac{3n}{4}+2\cdot (n_{b}+\left \lfloor b/2 \right \rfloor)$ rounds and the round number must be odd.
On MSP430 platform, it should have 95 rounds in total, which is our modified version based on Cazorla \textit{et al.}'s project.
In addition, we could hardly find cryptanalysis works on SEA block cipher.
Although, the original paper contains some attack analysis, they are not experiment results. Therefore, we leave the attack information on SEA not applicable.

    \item
\textbf{SIMON and SPECK}. SIMON and SPECK are presented in the same paper by Beaulieu \textit{et al.} \cite{beaulieu2015simon}
and they support different block sizes and key sizes. In this paper, we use 64-bit block and 128-bit key only for both SIMON and SPECK.
For SIMON, the best attack is 31 round (out of 44) using improved hull attack by Chen \textit{et al.} \cite{chen2016improved};
whereas for SPECK, the best attack is 19 round (out of 27) by Dinur \cite{dinur2014improved}.

    \item
\textbf{XTEA}. The XTEA \cite{wheeler1998correction} is a very old algorithm, but it is still very strong against attacks.
The greatest attack round by now is 27 rounds by Bogdanov \textit{et al.} \cite{bogdanov2012zero} with a time complexity of $2^{120.71}$.
\end{itemize}

Furthermore, the benchmark results on those ten algorithms are shown in Table \ref{tab-speed} and \ref{tab-size}.

\begin{table*}[tbp]
\centering
\caption{Block cipher performance with optimization setting (-O3) using ``gcc-6.4.0.32 win32'' compiler.
Column ``Code size'' and ``Internal state size'' are explained in Table \ref{tab-beg}.}
\label{tab-speed}
\begin{tabular}{lrrrrr}
    \toprule
Name     & Block size & Cycle count & Cycle per byte & Code size (bytes) & Internal state size (bytes) \\
    \midrule
AES128   & 128        & 12528       & 783            & 4634      & 18        \\
Camellia & 128        & 42960       & 2685           & 19866     & 268       \\
CLEFIA   & 128        & 38547       & 2409           & 4044      & 292       \\
LBlock   & 64         & 18282       & 2285.25        & 1126      & 10        \\
LEA      & 128        & 17014       & 1063           & 1724      & 44        \\
PRINCE   & 64         & 11001       & 1375           & 2960      & 22        \\
SEA      & 96         & 38072       & 3173           & 904       & 18        \\
SIMON    & 64         & 4627        & 578            & 676       & 5         \\
SPECK    & 64         & 10808       & 1351           & 382       & 1         \\
XTEA     & 64         & 22130       & 2766           & 384       & 24       \\
    \bottomrule
\end{tabular}
\end{table*}


\begin{table*}[tbp]
\centering
\caption{Block cipher performance with setting (-Os) using ``gcc-6.4.0.32 win32'' compiler.
Column ``Code size'' and ``Internal state size'' are explained in Table \ref{tab-beg}.}
\label{tab-size}
\begin{tabular}{lrrrrr}
    \toprule
Name     & Block size & Cycle count & Cycle per byte & Code size (bytes) & Internal state size (bytes) \\
    \midrule
AES128   & 128        & 26822       & 1676           & 1136      & 18        \\
Camellia & 128        & 42959       & 2685           & 19866     & 268       \\
CLEFIA   & 128        & 70658       & 4416           & 1784      & 292       \\
LBlock   & 64         & 18769       & 2346           & 704       & 10        \\
LEA      & 128        & 16646       & 1040           & 1678      & 44        \\
PRINCE   & 64         & 14916       & 1865           & 1006      & 22        \\
SEA      & 96         & 65177       & 5431           & 660       & 18        \\
SIMON    & 64         & 13198       & 9939           & 326       & 5         \\
SPECK    & 64         & 9939        & 1242           & 306       & 1         \\
XTEA     & 64         & 24423       & 3053           & 410       & 24       \\
    \bottomrule
\end{tabular}
\end{table*}


\section{Cryptographic Hash Functions}
Cryptographic hash functions take any length of input and return a fixed size-block hash value (checksum).
To return a fixed-size block hash value is very easy, simply by invoking a block cipher function.
However, to take any length of input to generate a fixed-size block is not that easy.
We need to apply one-way compression functions to block cipher functions.

\subsection{One-way Compression Functions} \label{sec-one}
A one-way compression function is supposed to take two fixed-size block and generate one fixed-size block.
To build hash functions from block cipher algorithms, the one-way compression function is also known as construction.

In our experiments, we use Prefix-Free Merkle--Damgard construction (PFMD) \cite{mirvaziri2007collision}, Matyas--Meyer--Oseas (MMO) construction \cite{wikipedia2017one}
and Miyaguchi--Preneel (MP) construction \cite{wikipedia2017one} to convert block cipher's decipher functions into hash functions.
When dealing with $a$-size-to-$b$-size constructions, I firstly tried to find authoritative research papers using different \textit{g}-functions.
However, as far as I searched, there was no such paper explaining the choice of \textit{g}-function.
Therefore, I referred to some open source security implementations.
There are mainly two types of implementations: padding zeros \cite{naoyukimorita2017},
duplicating inputs to perform $n$-to-$2n$ mapping \cite{nikhilvarghese2017}.

we decide to use padding zeros as the \textit{g}-functions to perform $a$-size-to-$b$-size mapping,
because the algorithms we select contain LBlock that uses 80-bit key and 64-bit block,
which does not suit the rest two mapping strategies; and the block sizes are less than or equal to the key sizes.
As a result, padding zeros is very flexible and suitable for our experiments.

% \subsection{Cryptographic Hash Functions}
% NOT GOING TO DO: \subsection{Pure Hash Function}

\subsection{Benchmark}
After I constructed the 30 hash functions \footnote{The 30 hash functions constructed by me: \url{https://github.cs.adelaide.edu.au/Mobile-Wireless-Systems-2017-S2/Crypto4RFID-1/tree/master/Hash/hash-testbench}.}
using PFMD, MMO and MP on the selected ten block cipher algorithms,
I need to benchmark the security and performance of those constructed hash functions,
because those hash functions are not guaranteed to be collision-free and safe.

We applied a tool called ``SMHasher'' \footnote{Our forked SMHasher: \url{https://github.com/MewX/smhasher/tree/master/src/ourhash}.}
to all those hash functions respectively.
This tool provides 14 tests:

\begin{enumerate}
    \item Sanity tests
    \item Speed tests
    \item Differential tests
    \item Differential-distribution tests
    \item Avalanche tests
    \item Bit Independence Criteria tests
    \item Keyset Cyclic tests
    \item Keyset TwoBytes tests
    \item Keyset Sparse tests
    \item Keyset Permutation tests
    \item Keyset Window tests
    \item Keyset Text tests
    \item Keyset Zero tests
    \item Keyset Seed tests
\end{enumerate}

However, this is our future work because I have not figured out the indicators on the report yet.

\subsection{Integration with the Whole System} \label{sec-int}
First of all, all the constructed hash functions have the same function signature, thus, the hash function can be changed seamlessly if we find an in-use one has some issues.
Also, our PC client is a cross-platform software, so I implemented the Python hash function interface to invoke original C codes.
It not only keeps the cross-platform feature, but also reduces the unnecessary workload of implementing hash function in Python again.

The hash function in the system takes two parameters: starting address, round count, nonce.
The starting address is the beginning address of the plain text and the nonce is either random number from PUF or the checksum from previous step.

The hash function calculates the resulting checksum for a whole block length from the starting address.
In each round, the starting address is converted to a new address by the \textit{t}-function.
Then, repeat this step until it calculates the checksum for ``round count'' times.


\section{Optimization}

\subsection{Compiler Optimization}

\subsection{High-Level Programming Language Optimization}
// TODO: methods

\subsection{Low-Level Programming Language Optimization} \label{sec-low}
// TOOD: online materials


% TODO: feedback from writing centre

\section{Conclusion}
// TODO:


% -----------

\bibliographystyle{ACM-Reference-Format}
\bibliography{ref}

\end{document}
