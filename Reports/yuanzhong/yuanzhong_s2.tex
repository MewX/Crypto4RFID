\documentclass[sigconf, review=false]{acmart}

\usepackage[utf8]{inputenc}
\usepackage{booktabs} % For formal tables
\usepackage{graphicx}
\graphicspath{{yuanzhong-imgs/}}
\usepackage{float}
\PassOptionsToPackage{hyphens}{url}
\usepackage{hyperref}
\usepackage{multirow}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{gensymb}
\usepackage{textcomp}
\usepackage{xspace}
\usepackage{threeparttable}

\let\OldTexttrademark\texttrademark
\renewcommand{\texttrademark}{\OldTexttrademark\xspace}%

%% template settings
\settopmatter{printacmref=false} % Removes citation information below abstract
\renewcommand\footnotetextcopyrightpermission[1]{} % removes footnote with conference information in first column


%% title and name
\begin{document}
\title{Mobile \& Wireless Systems Final Report}
\subtitle{Crypto4CRFID}

\author{Yuanzhong Xia}
\affiliation{
  \institution{The University of Adelaide}
  \city{Adelaide}
  \state{SA}
  \postcode{5005}
}
\email{a1700831@student.adelaide.edu.au}

% ---------
%% abstract
% ---------
\begin{abstract}
    CRFID is a version of RFID with an embedded microcontroller.
    With this microcontroller, we can implement a CRFID security system to make the communication between the reader and the CRFID more authenticated.
    I did some studies on ten secure lightweight block cipher algorithms and used their decipher functions to build 30 hash functions
    using Prefix-Free Merkle--Damgard, Matyas--Meyer--Oseas and Miyaguchi--Preneel constructions.
    Then I performed a benchmark using ``SHMasher'' to find the fastest secure hash function to be applied to our project.
    Finally, we successfully built a secure CRFID system using the fastest secure hash function: XTEA + Prefix-Free Merkle--Damgard.
\end{abstract}
\keywords{Embedded System, RFID, Encryption, Hash, MSP430, Optimization, Security}
\maketitle


% --------------
%% main contents
% --------------

% Excellent introduction and motivation of the project, clearly outlining the potential of the work.
\section{Introduction and Motivation}
Radio Frequency Identification (RFID) technologies are widely used in our daily lives:
student cards, contactless payment, object tracking (like airport baggage, express packages and experimental animals),
item identification, distributed wireless sensor networks used for environment monitoring, etc. \cite{wikipedia2017rfid}
They are normally built with Application Specific Integrated Circuits (ASIC).

Unlike RFID, Computational RFID (CRFID), which our studies are based on, has an ultra-low power microcontroller (MCU).
Thus it has a firmware software that we can specifically modify for our applications.
The firmware follows the EPC\texttrademark Radio-Frequency Identity Protocols Class-1 Generation-2 UHF RFID version 2\cite{epcglobal2013}.
This standard defines how a tag is captured by a reader, and how information is transmitted between reader and tag.
It also contains several custom security extension commands for developers to use in their implementations.

However, CRFID has a limited amount of computational resources, which determines that it is unlikely to have
modern high-computational-complex encryption algorithms (like RSA algorithm) applied to it.
Therefore, building a security system becomes a crucial problem in the research field.

In this project, we mainly tried to build a secure CRFID system
% Not implemented: the CRFID tag can verify a reader's legitimacy and
where the reader can identify a CRFID's legitimacy.
After passing the two-way verification, they can transfer critical data securely.

\subsection{Devices}
In this project, we use WISP 5 \footnote{WISP5 - WISP Home: \url{https://wisp5.wikispaces.com/WISP+Home}.} (shown in Figure \ref{fig-wisp5})
as the CRFID experimental device.
It contains a Texas Instruments (TI) MSP430FR5969 MCU \footnote{MSP430\texttrademark FR5969 16 MHz Ultra-Low-Power MCU: \url{http://www.ti.com/product/MSP430FR5969}.}
which uses 16-bit architecture with up to 16â€‘MHz Clock, and has 2 KB Static Random Access Memory (SRAM) and 64 KB Ferroelectric RAM (FRAM).

\begin{figure*}
\centering
\includegraphics[width=0.6\textwidth]{wisp5.png}
\caption{WISP 5 CRFID.}
\label{fig-wisp5}
\end{figure*}

The firmware is run by the MSP430 MCU. Hence, I only need to test algorithms on MSP430RF5969 no matter what CRFID I use.
Moreover, we have only one WISP 5, and another team member needs it to test the communication between CRFID and reader.
Therefore, I use another MSP430FR5969 that came with MSP430FR5969 LaunchPad Development Kit
\footnote{MSP-EXP430FR5969 MSP430FR5969 LaunchPad Development Kit: \url{http://www.ti.com/tool/MSP-EXP430FR5969}.},
shown in Figure \ref{fig-launchpad}.

\begin{figure}
\centering
\includegraphics[width=0.4\textwidth]{launchpad.jpg}
\caption{MSP430FR5969 LaunchPad.}
\label{fig-launchpad}
\end{figure}

For debugging, there is no difference theoretically, plus, it provides some additional useful tools
like EnergyTrace++\texttrademark, which can trace MCU current consumption.
As a result, all my experiments in this project were tested on this LaunchPad.

\subsection{System Overview}
The whole system architecture is shown in Figure \ref{fig-arch}.
This system contains two components: PC client and WISP 5.

\begin{figure*}
\centering
\includegraphics[width=0.7\textwidth]{arch.pdf}
\caption{System architecture.}
\label{fig-arch}
\end{figure*}

The PC client contains a database storing a copy of FRAM and SRAM signature
(used by Physical Unclonable Functions implemented by teammate Yang Su).
Each copy of FRAM and SRAM are indexed by unique EPC value.

The WISP 5 is supposed to contain a legitimate EPC value which is stored in the PC's database,
legitimate firmware which will be verified by my hash function,
and legitimate SRAM signature which is used for generating real random numbers.

The communication between PC client and WISP 5 follows the EPCglobal standard.
The extended security command is implemented by teammate Sangyeol Kim.
When a connection is established, the PC will send WISP 5 a challenge which contains the beginning address and the round count.
The round count is used together with \textit{t}-function (implemented by teammate Jingwen Shan),
which will be introduced in Section \ref{sec-int} in detail.
Once WISP 5 receives the challenge, it runs the hash function implemented by me to get a checksum and send it back to the PC client;
Meanwhile, the PC client uses the same hash function to calculate the checksum, and compare it with the received checksum.
If they match, the WISP 5 is regarded as a legitimate one.

\section{Related Works}
\subsection{Lightweight Block Cipher Algorithms}
Besides the cipher algorithm papers mentioned in Section \ref{sec-block},
there are 1some benchmark survey papers on lightweight block cipher algorithms:

\begin{itemize}
    \item In 2013, Cazorla \textit{et al.} published a survey paper comparing the performance among
          many lightweight block cipher algorithms using an MSP430 simulator called ``mspdebug''.
          \footnote{mspdebug GitHub repository: \url{https://github.com/dlbeer/mspdebug}.} \cite{cazorla2013survey}
    \item In 2014, Buhrow \textit{et al.} published a survey paper comparing different implementations
          of selected lightweight block cipher algorithms. \cite{buhrow2014block}
    \item In 2015, Cazorla \textit{et al.} again published a new survey paper comparing the performance among
          a set of lightweight block cipher algorithms using a real MSP430FG4618 device. \cite{cazorla2015survey}
    \item In 2017, Hatzivasilis \textit{et al.} published a survey on more than 30 lightweight block cipher algorithms.
          They did not benchmark all algorithms because some of their selected algorithms did not have reference implementations. \cite{hatzivasilis2017review}
\end{itemize}

However, the first three survey papers did not mention cryptanalysis of the selected block cipher algorithms.
The last paper mentioned the cryptanalysis, but it used the standard 8051 MCU and the ATtiny45, instead of MSP430.

Moreover, the two papers from Cazorla \textit{et al.} conflict with each other.
In addition, our experiment results on MSP430FR5969 conflict with Cazorla \textit{et al.}'s two papers.
That is also one of the project's motivations.

\subsection{Cryptographic Hash Functions}
As far as I know, there is no cryptographic hash function survey research from 2010.
A most-cited one is a survey paper from Bakhtiari \textit{et al.} in 1995 \cite{bakhtiari1995cryptographic}.
The functions they discussed in that paper are MD2, MD4, MD5 and SHA-1.
However, it is not useful now because all those discussed functions are fully attacked:

\begin{itemize}
    \item MD2 was shown to be vulnerable to collision by Muller in 2004,
          using a preimage attack with a time complexity equivalent to $2^{104}$. \cite{muller2004md2}
    \item MD4 was fully collided using cheap computational cost by Leurent
          using preimage attack in a time complexity of $2^{102}$ in 2008. \cite{leurent2008md4}
    \item The distribution of MD5 has been proved unsecure since 2004 \cite{hawkes2004musings}.
          Later in 2013, Xie \textit{et al.} published a method for a very quick collision attack \cite{xie2013fast},
          which takes less than a second to attack it on a regular computer.
    \item SHA-1 was also fully proved to be vulnerable to collision, using multi-block collision techniques
          by Wang \textit{et al.} since 2005. \cite{wang2005finding}
\end{itemize}

Besides, there are many cryptographic hash function papers using block ciphers to construct hash functions.
However, nearly all of the block ciphers are with key and block of same sizes.
I could not find a paper in which a hash function was constructed using key and block of different sizes.
This is not helpful, because the block ciphers we study are with various sizes of key and block.
Therefore, this is the reason why I refer to open-source projects to seek \textit{g}-functions used for constructions
in Section \ref{sec-one}.

\subsection{Algorithm Optimization on MSP430} \label{sec-alg-opt}
I have searched for ``assembly language'', ``MSP 430'' and ``Optimization'' key words on Google\texttrademark Scholar.
The only results that I can find are about factory assembly lines or sequences.

Additionally, the algorithms are evolutionary computation technologies. For example:

\begin{itemize}
    \item Dini \textit{et al.} derived a Genetic Algorithm to optimize assembling a simulated CAD product
          to find a better sequence that assembles quickly. \cite{dini1999generation}
    \item Haq \textit{et al.} derived a method to optimize load balance on assembly line
          using a hybrid genetic algorithm. \cite{haq2006hybrid}
\end{itemize}

Above all, there is no manual code optimization research
on assembly programming language or MSP430 programming.
Therefore, I referred to some online materials which are mentioned in Section \ref{sec-low}.


\section{Lightweight Block Cipher Algorithm} \label{sec-block}

A lightweight implementation is defined as requiring up to 32 KB ROM and 8 KB RAM by Manifavas \textit{et al.}'s work\cite{manifavas2014lightweight}.
All our selected lightweight algorithms satisfy these requirements.
Moreover, in this project, we need decipher functions only because cipher operations can be performed in a PC which has abundant computational resources.

In the beginning, we selected seven block cipher algorithms from Cazorla \textit{et al.}'s two papers \cite{cazorla2013survey, cazorla2015survey}.
Those seven algorithms were AES-128\cite{pub2001197}, LBlock\cite{wu2011lblock}, MIBS-64\cite{izadi2009mibs},
Piccolo-128\cite{shibutani2011piccolo}, SEA\cite{standaert2006sea}, SPECK64-128\cite{beaulieu2015simon}, XTEA\cite{needham1997tea, wheeler1998correction}.
The experiments results can be seen in Table \ref{tab-beg}.

\begin{table*}[tbp]
\centering
\caption{Experiments on AES-128, LBlock, MIBS-64, Piccolo-128, SEA, SPECK64-128 and XTEA,
using TI v16 compiler ``-O3 fastest'' optimization.
Column ``Begin'' means cumulated clock cycle counter at the entry of the decipher function;
while column ``End'' means the cumulated clock cycle count after the decipher function returns.
Therefore, column ``Cycle count'' equals to the difference between ``End'' and ``Begin''.
Code size is the decipher function's binary code size;
whereas the internal state size is the maximum size of in-use local variables (function parameters are excluded).}
\label{tab-beg}
\begin{tabular}{lcrrrrr}
    \toprule
Algorithm   & Type     & Begin & End   & Cycle count & Code size (bytes) & Internal state size (bytes) \\
    \midrule
AES         & decipher & 233   & 26303 & 26070       & 2538              & 18                          \\
LBlock      & decipher & 94    & 8300  & 8206        & 374               & 10                          \\
MIBS64      & decipher & 176   & 26312 & 26136       & 720               & 18                          \\
Piccolo128  & decipher & 215   & 16137 & 15922       & 2124              & 24                          \\
SEA         & decipher & 116   & 21682 & 21566       & 678               & 18                          \\
SPECK64-128 & decipher & 327   & 25328 & 25001       & 414               & 20                          \\
XTEA        & decipher & 115   & 12430 & 12315       & 666               & 24                          \\
    \bottomrule
\end{tabular}
\end{table*}

After that, I was informed of a new requirement - finding lightweight block cipher algorithms of which at least half rounds remained un-attacked.
As a result, I found that some of our candidates had been fully attacked.
These algorithms were: MIBS and PRESENT \cite{bogdanov2007present} full-round attacked by Sereshgi \textit{et al.} \cite{sereshgi2016biclique},
Piccolo full-round attacked by Han \textit{et al.} \cite{han2017improved}, Klein \cite{gong2011klein} full-round attacked by Ahmadian \textit{et al.} \cite{ahmadian2015biclique},
LED \cite{Guo:2011:LBC:2044928.2044958} and mCrypton \cite{lim2005mcrypton} full-round attacked by Jeong \textit{et al.} \cite{jeong2015weakness},
and TWINE \cite{suzaki2012twine} full-round attacked by Najarkolaei \textit{et al.} \cite{najarkolaei2016biclique}.
Those unsecure algorithms were excluded from this study.

Finally, the selected ten secure lightweight block cipher algorithms were:
AES-128, Camellia \cite{aoki2000camellia}, CLEFIA \cite{shirai2007128}, LBlock, LEA \cite{hong2013lea},
PRINCE \cite{borghoff2012prince}, SEA, SIMON \cite{beaulieu2015simon}, SPECK and XTEA.

My survey results on their cryptanalysis and best attack records are shown in Table \ref{tab-security}.

\begin{table*}[]
\centering
\begin{threeparttable}
\caption{Survey results on selected secure block cipher algorithms.}
\begin{tabular}{lrcrrr}
    \toprule
Name (block/key)   & Reference & Structure & Round (attacked/total) & Attack time complexity & Attack reference \\
    \midrule
AES128 (128/128) & \cite{pub2001197} & SPN & 7/10 & $2^{100}$ & \cite{derbez2013improved} \\
Camellia (128/128) & \cite{aoki2000camellia} & Feistel & 11/18 & $2^{121.3}$ & \cite{li2015meet} \\
CLEFIA (128/128) & \cite{shirai2007128} & Feistel & 14/18 & $2^{108}$ & \cite{li2015meet} \\
LBlock (64/80) & \cite{wu2011lblock} & Feistel   & 24/32 & $2^{75.42}$ & \cite{xie2017related} \\
LEA (128/128) & \cite{hong2013lea} & ARX & 14/24 & $2^{124.02}$ & \cite{song2016automatic} \\
PRINCE (64/128) & \cite{borghoff2012prince} & SPN & 9/12 & $2^{55.14}$ & \cite{cheng2017multidimensional} \\
SEA (96/96) & \cite{standaert2006sea} & Feistel & (N/A)/95 & N/A & N/A \\
SIMON (64/128) & \cite{beaulieu2015simon} & Feistel & 31/44 & $2^{119.62}A+2^{120.00}E$\tnote{*} & \cite{chen2016improved} \\
SPECK (64/128) & \cite{beaulieu2015simon} & Feistel & 19/27 & $2^{125}$ & \cite{dinur2014improved} \\
XTEA (64/128) & \cite{wheeler1998correction} & Feistel & 27/64 & $2^{120.71}$ & \cite{bogdanov2012zero} \\
    \bottomrule
\end{tabular}
\begin{tablenotes}
\item [*] $A$ means addition; $E$ means encryption;
\end{tablenotes}
\end{threeparttable}
\end{table*}

For those algorithms, we used the reference codes from Cazorla \textit{et al.}
\footnote{Source code developed in the BLOC project: \url{https://github.com/kmarquet/bloc}} by default.
If the algorithm was not implemented by Cazorla \textit{et al.}, the reference implementation would be mentioned in the following texts.

\begin{itemize}
    \item
\textbf{AES}. The AES \cite{pub2001197} is a very popular studied algorithm, and it has both hardware and software implementations.
In this paper, we discuss 128-bit-key version only. So far, successful 7-round (out of ten) attacks have been published by many researchers,
and the best time complexity we could find is $2^{100}$ by Derbez \textit{et al.} \cite{derbez2013improved}.

    \item
\textbf{Camellia}. The Camellia \cite{aoki2000camellia} has variable key sizes and we only study the 128-bit key size version with 128-bit block size.
The codes we use to test for this algorithm are the latest version (v1.2.0) from the company officially \cite{ntt2007},
and the greatest round attack is on 11-round by Li \textit{et al.} \cite{li2015meet}.

    \item
\textbf{CLEFIA}. The CLEFIA \cite{shirai2007128} is developed by Sony \cite{sony2008},
and it has 128-bit block and three different key size versions: 128-bit, 192-bit and 256-bit keys.
In this paper, we discuss 128-bit key version because smaller key versions are often faster.
Most attacks on CLEFIA are based on 192-bit key and 256-bit key versions. Hence there are fewer attacks on the 128-bit key version.
The greatest round attack we could find on 128-bit key version is on 14-round also by Li \textit{et al.} \cite{li2015meet}.

    \item
\textbf{LBlock}. The LBlock \cite{wu2011lblock} has 32 rounds with 64-bit block and 80-bit key.
The best attack using Related-Key Impossible Differential is on 24-round with a time complexity of $2^{75.42}$ by Xie \textit{et al.} \cite{xie2017related}.

    \item
\textbf{LEA}. The LEA \cite{hong2013lea} is designed for 32-bit processor which the authors think is the most common processor type,
and the best attack is 14-round attack by Song \textit{et al.} \cite{song2016automatic}.
It takes 128-bit key and 128-bit block. To test it on MSP430, we use an 8-bit implementation by KISA \cite{kisa2015}.

    \item
\textbf{PRINCE}. The PRINCE \cite{borghoff2012prince} takes 64-bit block and 128-bit key.
The best attack is on ninth round (out of 12) with time complexity of $2^{55.14}$.
This block cipher uses a lot of 64-bit operations which can be found on the reference implementation by Riou \cite{sebastienriou2016}.
Therefore, to test it on MSP430, we use an 8-bit implementation by Dare \cite{chrisdare2016}.

    \item
\textbf{SEA}. The SEA \cite{standaert2006sea} block cipher we use in this paper has 96-bit block size and key size.
According to the original paper, the author suggests to use $\frac{3n}{4}+2\cdot (n_{b}+\left \lfloor b/2 \right \rfloor)$ rounds, and the round number must be odd.
On MSP430 platform, it should have 95 rounds in total, which is our modified version based on Cazorla \textit{et al.}'s project.
Also, we could hardly find cryptanalysis works on SEA block cipher.
Although the original paper contains some attack analysis, they are not experiment results. Therefore, we leave the attack information on SEA not applicable.

    \item
\textbf{SIMON and SPECK}. SIMON and SPECK are presented in the same paper by Beaulieu \textit{et al.} \cite{beaulieu2015simon}
and they support different block sizes and key sizes. In this paper, we use 64-bit block and 128-bit key only for both SIMON and SPECK.
For SIMON, the best attack is 31 round (out of 44) using improved hull attack by Chen \textit{et al.} \cite{chen2016improved};
whereas for SPECK, the best attack is 19 round (out of 27) by Dinur \cite{dinur2014improved}.

    \item
\textbf{XTEA}. The XTEA \cite{wheeler1998correction} is a very old algorithm, but it is still very strong against attacks.
The greatest attack round by now is 27 rounds by Bogdanov \textit{et al.} \cite{bogdanov2012zero} with a time complexity of $2^{120.71}$.
\end{itemize}

Furthermore, the benchmark results on those ten algorithms are shown in Table \ref{tab-speed} and \ref{tab-size}.

\begin{table*}[tbp]
\centering
\caption{Block cipher performance with optimization setting (-O3) using ``gcc-6.4.0.32 win32'' compiler.
Column ``Code size'' and ``Internal state size'' are explained in Table \ref{tab-beg}.}
\label{tab-speed}
\begin{tabular}{lrrrrr}
    \toprule
Name     & Block size & Cycle count & Cycle per byte & Code size (bytes) & Internal state size (bytes) \\
    \midrule
AES128   & 128        & 12528       & 783            & 4634      & 18        \\
Camellia & 128        & 42960       & 2685           & 19866     & 268       \\
CLEFIA   & 128        & 38547       & 2409           & 4044      & 292       \\
LBlock   & 64         & 18282       & 2285.25        & 1126      & 10        \\
LEA      & 128        & 17014       & 1063           & 1724      & 44        \\
PRINCE   & 64         & 11001       & 1375           & 2960      & 22        \\
SEA      & 96         & 38072       & 3173           & 904       & 18        \\
SIMON    & 64         & 4627        & 578            & 676       & 5         \\
SPECK    & 64         & 10808       & 1351           & 382       & 1         \\
XTEA     & 64         & 22130       & 2766           & 384       & 24       \\
    \bottomrule
\end{tabular}
\end{table*}


\begin{table*}[tbp]
\centering
\caption{Block cipher performance with setting (-Os) using ``gcc-6.4.0.32 win32'' compiler.
Column ``Code size'' and ``Internal state size'' are explained in Table \ref{tab-beg}.}
\label{tab-size}
\begin{tabular}{lrrrrr}
    \toprule
Name     & Block size & Cycle count & Cycle per byte & Code size (bytes) & Internal state size (bytes) \\
    \midrule
AES128   & 128        & 26822       & 1676           & 1136      & 18        \\
Camellia & 128        & 42959       & 2685           & 19866     & 268       \\
CLEFIA   & 128        & 70658       & 4416           & 1784      & 292       \\
LBlock   & 64         & 18769       & 2346           & 704       & 10        \\
LEA      & 128        & 16646       & 1040           & 1678      & 44        \\
PRINCE   & 64         & 14916       & 1865           & 1006      & 22        \\
SEA      & 96         & 65177       & 5431           & 660       & 18        \\
SIMON    & 64         & 13198       & 9939           & 326       & 5         \\
SPECK    & 64         & 9939        & 1242           & 306       & 1         \\
XTEA     & 64         & 24423       & 3053           & 410       & 24       \\
    \bottomrule
\end{tabular}
\end{table*}


\section{Cryptographic Hash Functions}
Cryptographic hash functions take any length of input and return a fixed size-block hash value (checksum).
To return a fixed-size block hash value is very easy, simply by invoking a block cipher function.
However, to take any length of input to generate a fixed-size block is not that easy.
We need to apply one-way compression functions to block cipher functions.

\subsection{One-way Compression Functions} \label{sec-one}
A one-way compression function is supposed to take two fixed-size block and generate one fixed-size block.
To build hash functions from block cipher algorithms, the one-way compression function is also known as construction.

In our experiments, we used Prefix-Free Merkle--Damgard construction (PFMD) \cite{mirvaziri2007collision}, Matyas--Meyer--Oseas (MMO) construction \cite{wikipedia2017one}
and Miyaguchi--Preneel (MP) construction \cite{wikipedia2017one} to convert block cipher's decipher functions into hash functions.
When dealing with $a$-size-to-$b$-size constructions, I firstly tried to find authoritative research papers using different \textit{g}-functions.
However, as far as I searched, there was no such paper explaining the choice of \textit{g}-function.
Therefore, I referred to some open source security implementations.
There were mainly two types of implementations: padding zeros \cite{naoyukimorita2017},
duplicating inputs to perform $n$-to-$2n$ mapping \cite{nikhilvarghese2017}.

I decided to use padding zeros as the \textit{g}-functions to perform $a$-size-to-$b$-size mapping,
because the algorithms I selected contain LBlock that used an 80-bit key and a 64-bit block,
which did not suit the rest two mapping strategies; and the block sizes were less than or equal to the key sizes.
As a result, padding zeros was very flexible and suitable for our experiments.

% \subsection{Cryptographic Hash Functions}
% NOT GOING TO DO: \subsection{Pure Hash Function}

\subsection{Benchmark}
After I constructed the 30 hash functions \footnote{The 30 hash functions constructed by me: \url{https://github.cs.adelaide.edu.au/Mobile-Wireless-Systems-2017-S2/Crypto4RFID-1/tree/master/Hash/hash-testbench}.}
using PFMD, MMO and MP on the selected ten block cipher algorithms,
I needed to benchmark the security and performance of those constructed hash functions,
because those hash functions wer not guaranteed to be collision-free and safe.

We applied a tool called ``SMHasher'' \footnote{Our forked SMHasher: \url{https://github.com/MewX/smhasher/tree/master/src/ourhash}.}
to all those hash functions respectively.
This tool provided 14 tests:

\begin{enumerate}
    \item Sanity tests
    \item Speed tests
    \item Differential tests
    \item Differential-distribution tests
    \item Avalanche tests
    \item Bit Independence Criteria tests
    \item Keyset Cyclic tests
    \item Keyset TwoBytes tests
    \item Keyset Sparse tests
    \item Keyset Permutation tests
    \item Keyset Window tests
    \item Keyset Text tests
    \item Keyset Zero tests
    \item Keyset Seed tests
\end{enumerate}

Although this would be our future work because I had not figured out the indicators on the report yet,
from the reports generated by ``SMHasher'', I was able to select the best hash function roughly according to its collision probability and time spent.
This best hash function was ``XTEA using PFMD construction''.

\subsection{Integration with the Whole System} \label{sec-int}
First of all, all the constructed hash functions have the same function signature; thus, the hash function can be switched seamlessly if we find an in-use one has some issues.
Also, our PC client is a cross-platform software, so I implement the Python hash function interface to invoke original C codes.
It not only keeps the cross-platform feature but also reduces the unnecessary workload of implementing the hash function in Python again.

The hash function in the system takes two parameters: starting address, round count, nonce.
The starting address is the beginning address of the plain text, and the nonce is either random number from PUF or the checksum from the previous step.

The hash function calculates the resulting checksum for a whole block length from the starting address.
In each round, the starting address is converted to a new address by the \textit{t}-function.
Then, repeat this step until it calculates the checksum for ``round count'' times.

This process is run on both WISP 5 and PC, so that the final two checksums are compared with each other.
If they do not match, the WISP 5 is not authenticated and no further confidential communication will happen.
This authentication mechanism makes the CRFID system secure.


\section{Optimization}
The MSP430FR5969 MCU is 16-bit architecture.
If we use operations involving data size greater than 16 bit, those operations will be converted into 16-bit operations by compilers automatically.
Base on our experience, compiler's optimizations are always not optima.
That is why we still worth trying to optimize them manually.

\subsection{Compiler Optimization}
As far as I know, there are three compilers that support MSP430:

\begin{enumerate}
    \item TI compiler is a close-source implementation from TI.
    \item GNU gcc is powered by GNU open-source community, supporting plenty of instruction sets.
    \item LLVM is a set of compilers and toolchains \footnote{The LLVM Compiler Infrastructure: \url{https://llvm.org/}.}.
          To use it on MSP430, ``clang'' from LLVM is a must. It aims to deliver fast and best optimizations.
\end{enumerate}

Every compiler provides a set of optimization levels, and the ``min time option'' is always faster than ``min space option''.
The issue is TI does not support ``LLVM+clang'' officially; it is not easy to debug the product codes from ``LLVM+clang''.
I have to compile it and run the assembly codes from ``LLVM+clang''on MSP430 by myself.
Here are the cycle count experiments on ``XTEA'' decipher function:

\begin{enumerate}
    \item TI v16 compiler: 12391 (-O3)
    \item GNU gcc v6.4.0.32 compiler: 17572 (-O3)
    \item LLVM+clang v3.4: 12493 (-O3)
\end{enumerate}

From the experiments, TI's compiler performs better than the rest two.,
though, ``LLVM+clang'' is very close to TI's compiler.


\subsection{High-Level Programming Language Optimization}
As is mentioned that the MSP430 uses 16-bit architecture, it is beneficial to use native 16-bit operations in C codes,
instead of compiler-converted 16-bit operations.

Firstly, I checked whether Big Endian or Little Endian was used in MSP430.
From an official document \footnote{MSP430 Family Memory Organization: \url{http://www.ti.com/sc/docs/products/micro/msp430/userguid/ag_04.pdf}.},
I found that ``word'' type used Little Endian; whereas ``dword'' and ``qword'' were not mentioned.
However, I must know whether ``dword'' and ``qword'' used Little Endian or not
because there were many ``uint32\_t''and ``uint64\_t'' types in original implementations.
Without this information, I could not manually rewrite them into ``uint16\_t'' operations.

Therefore, after a manual testing by defining different types of variables and checking the memory states,
I found that all data are stored in Little Endian format.
Base on this information, I did the following attempts at high-level programming language optimization
on a hash function called ``BLAKE2s'' \cite{aumasson2016blake2x}.
The implementation was from Yang Su who was from AutoID Lab, and the optimization level was ``-O2 fastest''.
Detailed optimization logs can be found on my week 10 blog
\footnote{Week 10 blog: \url{https://github.cs.adelaide.edu.au/Mobile-Wireless-Systems-2017-S2/Crypto4RFID-1/wiki/Yuanzhong-Xia-Week-10-Blog-(a1700831)}.}.

\subsubsection{Shrinking data types}
Unnecessary big data types can be replaced with a little size type.
For example, there was a ``for loop'' indexer using ``uint16\_t''.
So, I modified it into ``uint8\_t'', and the clock cycle count reduced from 106,482 to 105,050.

\subsubsection{Replacing timing multiples of two}
I did an experiment on replacing a high-frequently used ``4 * i'' with ``i << 2'',
the final clock cycle count was not changed which indicated that the compiler had already optimized this operation.

\subsubsection{Replacing 32-bit operations directly with 16-bit operations.}
I did an experiment on replacing ``six 32-bit operations'' with ``three 32-bit operations and four 16-bit operations'',
the clock cycle count reduced from 105,050 to 99,742.

\subsubsection{Using XOR instead of OR}
I did an experiment on both using OR in a circular shift and using XOR in a circular shift.
The OR version took 258,941 cycles (double checked), while the XOR version took 99,742 cycles.

\subsubsection{C pointer typecasting}
Using the pointer typecasting on addresses can achieve fewer operations.
It highly depends on the original codes, and it does not often work effectively because it is still then optimized by the compiler.
The final clock cycle count is 96,919.

\subsection{Low-Level Programming Language Optimization} \label{sec-low}
As I mentioned in Section \ref{sec-alg-opt}, I failed to find researches on low-level programming language optimization.
As a result, I found some materials from online communities.

\begin{itemize}
    \item One is from StackOverflow \footnote{What are some tips for optimizing the assembly code generated by a compiler? \url{https://stackoverflow.com/a/3773213/4206925}.},
          which guides me to use as many registers as possible.
    \item Another one is from ``masmcode.com'' \footnote{\textit{Assembly Optimization Tips} by Mark Larson: \url{http://mark.masmcode.com/}.},
          which drives many examples on how I can optimize the assembly level codes.
\end{itemize}

This remained to be a future work because I had not figured out a way to make TI's compiler to generate runnable assembly codes in current stage.


\section{Conclusion}
Studies on lightweight block cipher algorithms, cryptographic hash functions and optimizations went well in the project.
Based on those studies, our team finally built a secure CRFID system in which the reader could verify the legitimacy of a CRFID using the studied hash function - XTEA using PFMD construction.
Further, this system could prevent random replay attack because the nonce was uniquely generated from SRAM.

During the development process, I learned a lot on doing researches, such as the ways to look for information, and the ways to analyse others' experiments.
Also, from writing centre session, I finally learned how to write abstract and that I should use past tense for stating experiment results.


\section{Acknowledgement}
Without the help of course supervisor Damith, AutoID Lab researchers Yang and Michael's help,
the studies would be impossible to go this far and produce a new survey on the cryptanalysis information on lightweight block cipher algorithms.

Also, teammates Sangyeol, Jingwen and Yang did a lot in their components. The project was impossible to be finished without their efforts.


% -----------

\bibliographystyle{ACM-Reference-Format}
\bibliography{ref}

\end{document}
